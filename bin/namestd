#!/usr/bin/env bash
# Arquivo: namestd
# Autor: Bruno Franco
# Ultima_modificacao: 10-03-2023
# Download: git@github.com:brnfra
# Licence:Este arquivo é de domínio público
# Garantia: O autor não se responsabiliza por eventuais danos
#           causados pelo uso deste script.
#change names for standard. Ex.: 's p c' => s_p_c; and so on...
#The changes is restrict on the folder where the script was executed
#first, make some general changes, just in case(remove spaces)
first_check() {    #{{{
    LOCAL=$(pwd)
    FILE=$1
    #	${variable//search/replace}
    OLD=${FILE//$LOCAL\//}
    NAME=${FILE//$LOCAL\//}
    NAME=${NAME// /_}
    NAME=${NAME//'$'/_}
    NAME=$(echo "$NAME" | sed -r 's/(\s)+/_/gi')
    NAME=$(echo "$NAME" | tr '\n\r\a\b\f\v\t' '_' | sed -r 's/_$//gi')
    # coding to ascII remove latin chars
    NAME=$(iconv -f UTF8 -t ASCII//TRANSLIT<<< "$NAME")
    if [ -f "$NAME" ] && [ -f "$OLD" ] && [ "$NAME" != "$OLD" ]; then
	echo "antes1 =  $OLD"
	echo "depois1 = $NAME"
    fi
    if [[ "$NAME" != "$OLD" ]]
    then
	mv -n "$OLD" "$NAME" &>/dev/null
    fi
}
#}}}
rename_file() {			#{{{
    FILE=$1
    OLD=$FILE
    NAME=${FILE// /_}
    NAME=$(iconv -f UTF8 -t ASCII//TRANSLIT<<< "$NAME")
    if [[ $NAME == *"."* ]]; then
	#{{{
	#get after dot.
	EXT=${NAME##*'.'}
	#get before dot.
	NAME=${NAME%.*}
	NAME=${NAME//[\\+]/}
	NAME=$(echo "$NAME" | sed -r 's/[^A-Za-z0-9_\.]/_/gi')
	NAME=$(echo "$NAME" | sed -r 's/[[:space:]]/_/g ')
	NAME=$(echo "$NAME" | sed -r 's/_+/_/gi')
	NAME=$(echo "$NAME" | sed -r 's/^_//gi')
	NAME=$(echo "$NAME" | sed -r 's/_$//gi')
	if [[ $NAME == "" ]]; then
	    NAME="new_renamed_file"
	fi
	EXT=$(echo "$EXT" | sed -r 's/\W/_/gi')
	EXT=$(echo "$EXT" | sed -r 's/[[:space:]]/_/g')
	EXT=$(echo "$EXT" | sed -r 's/_+/_/gi')
	EXT=$(echo "$EXT" | sed -r 's/^_//gi')
	EXT=$(echo "$EXT" | sed -r 's/_$//gi')
	NAME=$NAME.$EXT
	#}}}
    else
	#{{{
	NAME=${NAME//[\\+]/}
	NAME=$(echo "$NAME" | sed -r 's/\W/_/gi')
	NAME=$(echo "$NAME" | sed -r 's/[[:space:]]/_/gi')
	NAME=$(echo "$NAME" | sed -r 's/(_+)+/_/gi')
	NAME=$(echo "$NAME" | sed -r 's/^_//gi')
	NAME=$(echo "$NAME" | sed -r 's/_$//gi')
	if [[ $NAME == "" ]]; then
	    NAME="new_renamed_file"
	fi
	#}}}
    fi
    if [[ "$NAME" != "$OLD" ]]
    then
	if [ -f "$NAME" ]; then
	    COUNT=$(( 2 ))
	    NAME="${NAME}_"
	    while
		NAME=${NAME%_*}
		NAME=${NAME}_$COUNT
		mv -n "$OLD" "$NAME" &>/dev/null
		COUNT=$(( COUNT + 1))
		[ -f "$NAME" ]
	    do true; done
	else
	    mv -n "$OLD" "$NAME" &>/dev/null
	fi
    fi
}
#}}}
rename_folder() {   #{{{
    FOLDER=$1
    OLD=$FOLDER
    NAME=$FOLDER
    NAME=$(iconv -f UTF8 -t ASCII//TRANSLIT<<< "$NAME")
    NAME=${NAME//[\\+]/}
    NAME=${NAME//'$'/}
    #in case the first has been _ sbst ""
    NAME=${NAME/#_/}
    NAME=$(echo "$NAME" | sed -r 's/[[:space:]]/_/g; ')
    NAME=$(echo "$NAME" | sed -r 's/[^.^\w^\-^[0-9]]/_/gi')
    NAME=$(echo "$NAME" | sed -r 's/_+/_/gi')
    NAME=$(echo "$NAME" | sed -r 's/^_//gi')
    NAME=$(echo "$NAME" | sed -r 's/_$//gi')
    NAME=$(echo "$NAME" | sed -r 's/\W$//gi')
    if [[ "$NAME" != "$OLD" ]]
    then
	if [[ "$NAME" == "/" ]]
	then
	    echo "Folder's name is empty"
	else
	    mv -n "$OLD" "$NAME" &>/dev/null
	fi
    fi
}
#}}}
show_result() { #{{{
    printf "\n%s\n\n" "Changes table"
    FOLDERS_AFTER=$(find . -maxdepth 1 -type d | sed 's|\.\/||gi' | sed '1d'| sort)
    FILES_AFTER=$(find . -maxdepth 1 -type f | sed 's|\.\/||gi' | sed '1d'| sort)
    FOLDERS_AFTER=${FOLDERS_AFTER//$LOCAL\//}
    FILES_AFTER=${FILES_AFTER//$LOCAL\//}
    folders_after=( $FOLDERS_AFTER )
    folders_before=( $FOLDERS_BEFORE )
    files_after=( $FILES_AFTER )
    files_before=( $FILES_BEFORE )
    lenght=${#folders_before[@]}
    for(( i=0; i < lenght; i++))
    do
	printf "\t%s%-20s%s%10s%-20s\n" "[" "${folders_before[$i]}" "]" " ----> " " [${folders_after[$i]}]"
    done
    echo
    lenght=${#files_before[@]}
    for(( i=0; i < lenght; i++))
    do
	printf "\t%s%-20s%s%10s%-20s\n" "[" "${files_before[$i]}" "]" " ----> " " [${files_after[$i]}]"
    done
    echo
}
#}}}
LOCAL=$(pwd)
if [ "$LOCAL" = "$HOME" ]; then
    printf "Script avoid execute in [%s] directory.\n" "$HOME"
    exit 1
fi
FOLDERS_BEFORE=$(find . -maxdepth 1 -type d | sed 's|\.\/||gi' | sed '1d'| sort)
FILES_BEFORE=$(find . -maxdepth 1 -type f | sed 's|\.\/||gi' | sed '1d'| sort)
FOLDERS_BEFORE=${FOLDERS_BEFORE//$LOCAL\//}
FILES_BEFORE=${FILES_BEFORE//$LOCAL\//}
NAMES="$(pwd)"/*
for FILE in $NAMES
do
    first_check "$FILE"
done
FILES=$(find . -maxdepth 1 -type f -exec ls  {} +  | sed 's|\.\/||gi') &> /dev/null
STFILES=$?
if [[ $STFILES -eq 0 ]]
then
    DEFAULT_IFS=$IFS
    IFS=$'\n'
    files=( $FILES )
    IFS=$DEFAULT_IFS

    lenght=${#files[@]}
    for(( i=0; i < lenght; i++))
    do
	rename_file "${files[$i]}"
    done
else
    printf "\n\t%-20s\n" "No file founded."
fi
FOLDERS="$(find . -maxdepth 1 -type d -name '*' | sed 's|\.\/||gi' | sed '1d')" &> /dev/null
STFOLDERS=$?
if [[ $STFOLDERS -eq 0 ]]
then
    DEFAULT_IFS=$IFS
    IFS=$'\n'
    folders=( $FOLDERS )
    IFS=$DEFAULT_IFS
    lenght=${#folders[@]}
    for(( i=0; i < lenght; i++))
    do
	rename_folder "${folders[$i]}"
    done

else
    printf "\n\t%-20s\n\n\n" "No folder founded."
fi
show_result
